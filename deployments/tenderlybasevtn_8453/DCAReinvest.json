{"metadata":"{\"defaultCompiler\":{\"version\":\"0.8.20\"},\"sources\":{\"contracts/base/DCAReinvest.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {DCAReinvestLogic, ReinvestCodes, IDCADataStructures, IDCAReinvest} from \\\"../logic/ReinvestLogic.sol\\\";\\nimport \\\"../security/onlyActive.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *      Distributed Cost Average Contracts\\n ************************************************\\n *                  V0.7\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\ncontract DCAReinvest is DCAReinvestLogic, OnlyActive, Ownable {\\n    using ReinvestCodes for uint8;\\n\\n    /**\\n     * @dev Constructor for the DCAReinvest contract\\n     * @param activeLibrary_ The state of the reinvest library\\n     */\\n    constructor(bool activeLibrary_) Ownable(msg.sender) {\\n        _setActiveState(activeLibrary_);\\n    }\\n\\n    /**\\n     * @dev Executes the reinvestment\\n     * @param reinvestData_ The reinvestment data\\n     * @param amount_ The amount to reinvest\\n     * @return amount The amount of the reinvestment\\n     * @return success The success of the reinvestment\\n     */\\n\\n    function executeReinvest(\\n        IDCADataStructures.Reinvest memory reinvestData_,\\n        uint256 amount_\\n    ) external override is_active returns (uint256 amount, bool success) {\\n        return _executeInvest(reinvestData_, amount_);\\n    }\\n    /**\\n     * @dev Unwinds the reinvestment\\n     * @param reinvestData_ The reinvestment data\\n     * @param amount_ The amount to unwind\\n     * @return amount The amount of the unwind\\n     * @return success The success of the unwind\\n     */\\n    function unwindReinvest(\\n        IDCADataStructures.Reinvest memory reinvestData_,\\n        uint256 amount_\\n    ) external override returns (uint256 amount, bool success) {\\n        return _executeWithdraw(reinvestData_, amount_);\\n    }\\n\\n    /**\\n     * @dev Returns the version of the reinvest library\\n     * @return The version of the reinvest library\\n     */\\n    function getLibraryVersion() public pure returns (string memory) {\\n        return REINVEST_VERSION;\\n    }\\n    /**\\n     * @dev Returns whether the reinvest library is active\\n     * @return Whether the reinvest library is active\\n     */\\n    function isActive()\\n        external\\n        view\\n        override(IDCAReinvest, OnlyActive)\\n        returns (bool)\\n    {\\n        return _getActiveState();\\n    }\\n\\n    /**\\n     * @dev Returns the active moduals\\n     * @return The active moduals\\n     */\\n    function getActiveModuals()\\n        external\\n        pure\\n        override\\n        returns (uint8[] memory)\\n    {\\n        return abi.decode(ACTIVE_REINVESTS, (uint8[]));\\n    }\\n\\n    /**\\n     * @dev Sets the active state of the reinvest library\\n     */\\n    function setActiveState() public onlyOwner {\\n        _setActiveState(!_getActiveState());\\n    }\\n\\n    /**\\n     * @dev Returns the module name for the given code\\n     * @param code_ The code to get the module name for\\n     * @return The module name for the given code\\n     */\\n    function getModuleName(uint8 code_) external pure returns (string memory) {\\n        return code_._getModuleName();\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/library/Codes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {ForwardReinvest} from \\\"../modules/ForwardReinvest.sol\\\";\\nimport {AaveV3Reinvest} from \\\"../modules/AaveV3Reinvest.sol\\\";\\n\\nimport {CompoundV3Reinvest} from \\\"../modules/CompoundV3Reinvest.sol\\\";\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *      Distributed Cost Average Contracts\\n ************************************************\\n *                  V0.7\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\nlibrary ReinvestCodes {\\n    uint8 constant NOT_ACTIVE = 0x00;\\n    uint8 constant FORWARD = 0x01;\\n\\n    uint8 constant COMPOUND = 0x11;\\n    uint8 constant AAVE = 0x12;\\n    uint8 constant HOP = 0x13;\\n    uint8 constant POOLTOGETHER_ETH = 0x14;\\n    uint8 constant LIDO_STETH = 0x15;\\n\\n    /**\\n     * @notice Checks if the have_ code matches the want_ code\\n     * @param have_ The code to check\\n     * @param want_ The code to compare against\\n     * @return True if the codes match, false otherwise\\n     */\\n    function checkCode(uint8 have_, uint8 want_) internal pure returns (bool) {\\n        return have_ == want_;\\n    }\\n\\n    /**\\n     * @notice Returns the module name for the given code\\n     * @param code_ The code to get the module name for\\n     * @return moduleName The module name\\n     */\\n    function _getModuleName(\\n        uint8 code_\\n    ) internal pure returns (string memory moduleName) {\\n        if (checkCode(code_, ReinvestCodes.NOT_ACTIVE))\\n            moduleName = \\\"Not Active\\\";\\n        else if (checkCode(code_, ReinvestCodes.FORWARD))\\n            moduleName = ForwardReinvest.MODULE_NAME;\\n        else if (checkCode(code_, ReinvestCodes.AAVE))\\n            moduleName = AaveV3Reinvest.MODULE_NAME;\\n        else if (checkCode(code_, ReinvestCodes.COMPOUND))\\n            moduleName = CompoundV3Reinvest.MODULE_NAME;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"versionPragma\":\">=0.4.22 <0.9.0\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/modules/ForwardReinvest.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n//DEV\\nimport \\\"hardhat/console.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ReinvestCodes} from \\\"../library/Codes.sol\\\";\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *       Dollar Cost Average Contracts\\n ************************************************\\n *                  V0.6\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\nlibrary ForwardReinvest {\\n    string public constant MODULE_NAME = \\\"Forward Reinvest V0.2\\\";\\n    uint8 public constant MODULE_ID = 0x01;\\n\\n    struct ReinvestDataStruct {\\n        uint8 moduleCode;\\n        address receiver;\\n        address token;\\n    }\\n\\n    function _execute(\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal returns (uint256, bool success) {\\n        ReinvestDataStruct memory investData = _decodeData(data_);\\n        if (investData.token == address(0))\\n            (success, ) = payable(address(investData.receiver)).call{\\n                value: amount_\\n            }(\\\"\\\");\\n        else\\n            success = IERC20(investData.token).transfer(\\n                investData.receiver,\\n                amount_\\n            );\\n\\n        return (amount_, success);\\n    }\\n\\n    function _unwind(\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal pure returns (uint256 amount, bool success) {\\n        //  There isn't any investments to unwind in the forward\\n        return (0, true);\\n    }\\n\\n    function _decodeData(\\n        bytes memory data_\\n    ) private pure returns (ReinvestDataStruct memory) {\\n        return abi.decode(data_, (ReinvestDataStruct));\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/protocols/aaveV3/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ninterface AaveIPool {\\n    /**\\n     * @dev Emitted on mintUnbacked()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address initiating the supply\\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\\n     * @param amount The amount of supplied assets\\n     * @param referralCode The referral code used\\n     */\\n    event MintUnbacked(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint16 indexed referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted on backUnbacked()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param backer The address paying for the backing\\n     * @param amount The amount added as backing\\n     * @param fee The amount paid in fees\\n     */\\n    event BackUnbacked(\\n        address indexed reserve,\\n        address indexed backer,\\n        uint256 amount,\\n        uint256 fee\\n    );\\n\\n    /**\\n     * @dev Emitted on supply()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address initiating the supply\\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\\n     * @param amount The amount supplied\\n     * @param referralCode The referral code used\\n     */\\n    event Supply(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint16 indexed referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted on withdraw()\\n     * @param reserve The address of the underlying asset being withdrawn\\n     * @param user The address initiating the withdrawal, owner of aTokens\\n     * @param to The address that will receive the underlying\\n     * @param amount The amount to be withdrawn\\n     */\\n    event Withdraw(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted on repay()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The beneficiary of the repayment, getting his debt reduced\\n     * @param repayer The address of the user initiating the repay(), providing the funds\\n     * @param amount The amount repaid\\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\\n     */\\n    event Repay(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed repayer,\\n        uint256 amount,\\n        bool useATokens\\n    );\\n\\n    /**\\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\\n     * @param asset The address of the underlying asset of the reserve\\n     * @param totalDebt The total isolation mode debt for the reserve\\n     */\\n    event IsolationModeTotalDebtUpdated(\\n        address indexed asset,\\n        uint256 totalDebt\\n    );\\n\\n    /**\\n     * @dev Emitted when the user selects a certain asset category for eMode\\n     * @param user The address of the user\\n     * @param categoryId The category id\\n     */\\n    event UserEModeSet(address indexed user, uint8 categoryId);\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     */\\n    event ReserveUsedAsCollateralEnabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     */\\n    event ReserveUsedAsCollateralDisabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on rebalanceStableBorrowRate()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user for which the rebalance has been executed\\n     */\\n    event RebalanceStableBorrowRate(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted when a borrower is liquidated.\\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\\n     * @param liquidator The address of the liquidator\\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     */\\n    event LiquidationCall(\\n        address indexed collateralAsset,\\n        address indexed debtAsset,\\n        address indexed user,\\n        uint256 debtToCover,\\n        uint256 liquidatedCollateralAmount,\\n        address liquidator,\\n        bool receiveAToken\\n    );\\n\\n    /**\\n     * @dev Emitted when the state of a reserve is updated.\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param liquidityRate The next liquidity rate\\n     * @param stableBorrowRate The next stable borrow rate\\n     * @param variableBorrowRate The next variable borrow rate\\n     * @param liquidityIndex The next liquidity index\\n     * @param variableBorrowIndex The next variable borrow index\\n     */\\n    event ReserveDataUpdated(\\n        address indexed reserve,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 variableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex\\n    );\\n\\n    /**\\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\\n     * @param reserve The address of the reserve\\n     * @param amountMinted The amount minted to the treasury\\n     */\\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\\n\\n    /**\\n     * @notice Mints an `amount` of aTokens to the `onBehalfOf`\\n     * @param asset The address of the underlying asset to mint\\n     * @param amount The amount to mint\\n     * @param onBehalfOf The address that will receive the aTokens\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function mintUnbacked(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @notice Back the current unbacked underlying with `amount` and pay `fee`.\\n     * @param asset The address of the underlying asset to back\\n     * @param amount The amount to back\\n     * @param fee The amount paid in fees\\n     * @return The backed amount\\n     */\\n    function backUnbacked(\\n        address asset,\\n        uint256 amount,\\n        uint256 fee\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n     * @param asset The address of the underlying asset to supply\\n     * @param amount The amount to be supplied\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function supply(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\n     * @param asset The address of the underlying asset to supply\\n     * @param amount The amount to be supplied\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param deadline The deadline timestamp that the permit is valid\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     * @param permitV The V parameter of ERC712 permit sig\\n     * @param permitR The R parameter of ERC712 permit sig\\n     * @param permitS The S parameter of ERC712 permit sig\\n     */\\n    function supplyWithPermit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode,\\n        uint256 deadline,\\n        uint8 permitV,\\n        bytes32 permitR,\\n        bytes32 permitS\\n    ) external;\\n\\n    /**\\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n     * @param asset The address of the underlying asset to withdraw\\n     * @param amount The underlying amount to be withdrawn\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n     * @param to The address that will receive the underlying, same as msg.sender if the user\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n     *   different wallet\\n     * @return The final amount withdrawn\\n     */\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n     * @param asset The address of the underlying asset to borrow\\n     * @param amount The amount to be borrowed\\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n     * if he has been given credit delegation allowance\\n     */\\n    function borrow(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        uint16 referralCode,\\n        address onBehalfOf\\n    ) external;\\n\\n    /**\\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n     * other borrower whose debt should be removed\\n     * @return The final amount repaid\\n     */\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n     * other borrower whose debt should be removed\\n     * @param deadline The deadline timestamp that the permit is valid\\n     * @param permitV The V parameter of ERC712 permit sig\\n     * @param permitR The R parameter of ERC712 permit sig\\n     * @param permitS The S parameter of ERC712 permit sig\\n     * @return The final amount repaid\\n     */\\n    function repayWithPermit(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        address onBehalfOf,\\n        uint256 deadline,\\n        uint8 permitV,\\n        bytes32 permitR,\\n        bytes32 permitS\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\\n     * equivalent debt tokens\\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\\n     * balance is not enough to cover the whole debt\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n     * @return The final amount repaid\\n     */\\n    function repayWithATokens(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\\n     * @param asset The address of the underlying asset borrowed\\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\\n     */\\n    function swapBorrowRateMode(\\n        address asset,\\n        uint256 interestRateMode\\n    ) external;\\n\\n    /**\\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\n     * - Users can be rebalanced if the following conditions are satisfied:\\n     *     1. Usage ratio is above 95%\\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\\n     * @param asset The address of the underlying asset borrowed\\n     * @param user The address of the user to be rebalanced\\n     */\\n    function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n    /**\\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\\n     * @param asset The address of the underlying asset supplied\\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\\n     */\\n    function setUserUseReserveAsCollateral(\\n        address asset,\\n        bool useAsCollateral\\n    ) external;\\n\\n    /**\\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     */\\n    function liquidationCall(\\n        address collateralAsset,\\n        address debtAsset,\\n        address user,\\n        uint256 debtToCover,\\n        bool receiveAToken\\n    ) external;\\n\\n    /**\\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n     * as long as the amount taken plus a fee is returned.\\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n     * into consideration. For further details please visit https://docs.aave.com/developers/\\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\\n     * @param assets The addresses of the assets being flash-borrowed\\n     * @param amounts The amounts of the assets being flash-borrowed\\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\n     * @param params Variadic packed params to pass to the receiver as extra information\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function flashLoan(\\n        address receiverAddress,\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata interestRateModes,\\n        address onBehalfOf,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n     * as long as the amount taken plus a fee is returned.\\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n     * into consideration. For further details please visit https://docs.aave.com/developers/\\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\\n     * @param asset The address of the asset being flash-borrowed\\n     * @param amount The amount of the asset being flash-borrowed\\n     * @param params Variadic packed params to pass to the receiver as extra information\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function flashLoanSimple(\\n        address receiverAddress,\\n        address asset,\\n        uint256 amount,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @notice Returns the user account data across all the reserves\\n     * @param user The address of the user\\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\\n     * @return currentLiquidationThreshold The liquidation threshold of the user\\n     * @return ltv The loan to value of The user\\n     * @return healthFactor The current health factor of the user\\n     */\\n    function getUserAccountData(\\n        address user\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralBase,\\n            uint256 totalDebtBase,\\n            uint256 availableBorrowsBase,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n\\n    /**\\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\\n     * interest rate strategy\\n     * @dev Only callable by the PoolConfigurator contract\\n     * @param asset The address of the underlying asset of the reserve\\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\\n     */\\n    function initReserve(\\n        address asset,\\n        address aTokenAddress,\\n        address stableDebtAddress,\\n        address variableDebtAddress,\\n        address interestRateStrategyAddress\\n    ) external;\\n\\n    /**\\n     * @notice Drop a reserve\\n     * @dev Only callable by the PoolConfigurator contract\\n     * @param asset The address of the underlying asset of the reserve\\n     */\\n    function dropReserve(address asset) external;\\n\\n    /**\\n     * @notice Updates the address of the interest rate strategy contract\\n     * @dev Only callable by the PoolConfigurator contract\\n     * @param asset The address of the underlying asset of the reserve\\n     * @param rateStrategyAddress The address of the interest rate strategy contract\\n     */\\n    function setReserveInterestRateStrategyAddress(\\n        address asset,\\n        address rateStrategyAddress\\n    ) external;\\n\\n    /**\\n     * @notice Rescue and transfer tokens locked in this contract\\n     * @param token The address of the token\\n     * @param to The address of the recipient\\n     * @param amount The amount of token to transfer\\n     */\\n    function rescueTokens(address token, address to, uint256 amount) external;\\n\\n    /**\\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n     * @dev Deprecated: Use the `supply` function instead\\n     * @param asset The address of the underlying asset to supply\\n     * @param amount The amount to be supplied\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/modules/AaveV3Reinvest.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n//import {Pool} from \\\"@aave/core-v3/contracts/protocol/pool/Pool.sol\\\";\\nimport {ReinvestCodes} from \\\"../library/Codes.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {AaveIPool} from \\\"../protocols/aaveV3/IPool.sol\\\";\\n\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *       Dollar Cost Average Contracts\\n ************************************************\\n *                  V0.6\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\nlibrary AaveV3Reinvest {\\n    string public constant MODULE_NAME = \\\"Aave V3 Reinvest\\\";\\n    uint8 public constant MODULE_ID = 0x12;\\n\\n    address constant AAVE_CONTRACT = 0xA238Dd80C259a72e81d7e4664a9801593F98d1c5; //ETH SEPOLIA\\n    AaveIPool constant AAVE_POOL = AaveIPool(AAVE_CONTRACT);\\n\\n    /**\\n     * @dev The reinvest data structure\\n     *\\n     */\\n    struct ReinvestDataStruct {\\n        uint8 moduleCode; // Module code\\n        address token;\\n        address aToken;\\n    }\\n\\n    /**\\n     * @dev Executes the reinvest logic\\n     * @param amount_ The amount of tokens to reinvest\\n     * @param data_ The encoded reinvest data\\n     * @return amount The amount of tokens reinvested\\n     * @return success A boolean indicating success\\n     */\\n    function _execute(\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal returns (uint256 amount, bool success) {\\n        ReinvestDataStruct memory investData = _decodeData(data_);\\n\\n        uint256 oldBalance = IERC20(investData.aToken).balanceOf(address(this));\\n\\n        bool approvalSuccess = IERC20(investData.token).approve(\\n            address(AAVE_POOL),\\n            amount_\\n        );\\n\\n        if (approvalSuccess) {\\n            AAVE_POOL.supply(investData.token, amount_, address(this), 0);\\n\\n            uint256 newBalance = IERC20(investData.aToken).balanceOf(\\n                address(this)\\n            );\\n\\n            amount = newBalance - oldBalance;\\n            success = amount > 0;\\n        }\\n\\n        return (amount, success);\\n    }\\n\\n    /**\\n     * @dev Unwinds the reinvest logic\\n     * @param amount_ The amount of tokens to unwind\\n     * @param data_ The encoded unwind data\\n     * @return amount The amount of tokens unwound\\n     * @return success A boolean indicating success\\n     */\\n    function _unwind(\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal returns (uint256 amount, bool success) {\\n        ReinvestDataStruct memory investData = _decodeData(data_);\\n        amount = AAVE_POOL.withdraw(investData.token, amount_, address(this));\\n\\n        success = amount > 0;\\n        return (amount, success);\\n    }\\n\\n    /**\\n     * @dev Decodes the reinvest data\\n     * @param data_ The encoded reinvest data\\n     * @return The reinvest data structure\\n     */\\n    function _decodeData(\\n        bytes memory data_\\n    ) private pure returns (ReinvestDataStruct memory) {\\n        return abi.decode(data_, (ReinvestDataStruct));\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/protocols/compoundV3/CometConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/**\\n * @title Compound's Comet Configuration Interface\\n * @author Compound\\n */\\ncontract CometConfiguration {\\n    struct ExtConfiguration {\\n        bytes32 name32;\\n        bytes32 symbol32;\\n    }\\n\\n    struct Configuration {\\n        address governor;\\n        address pauseGuardian;\\n        address baseToken;\\n        address baseTokenPriceFeed;\\n        address extensionDelegate;\\n        uint64 supplyKink;\\n        uint64 supplyPerYearInterestRateSlopeLow;\\n        uint64 supplyPerYearInterestRateSlopeHigh;\\n        uint64 supplyPerYearInterestRateBase;\\n        uint64 borrowKink;\\n        uint64 borrowPerYearInterestRateSlopeLow;\\n        uint64 borrowPerYearInterestRateSlopeHigh;\\n        uint64 borrowPerYearInterestRateBase;\\n        uint64 storeFrontPriceFactor;\\n        uint64 trackingIndexScale;\\n        uint64 baseTrackingSupplySpeed;\\n        uint64 baseTrackingBorrowSpeed;\\n        uint104 baseMinForRewards;\\n        uint104 baseBorrowMin;\\n        uint104 targetReserves;\\n        AssetConfig[] assetConfigs;\\n    }\\n\\n    struct AssetConfig {\\n        address asset;\\n        address priceFeed;\\n        uint8 decimals;\\n        uint64 borrowCollateralFactor;\\n        uint64 liquidateCollateralFactor;\\n        uint64 liquidationFactor;\\n        uint128 supplyCap;\\n    }\\n}\\n\",\"versionPragma\":\"0.8.20\"},\"contracts/protocols/compoundV3/CometMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/**\\n * @title Compound's Comet Math Contract\\n * @dev Pure math functions\\n * @author Compound\\n */\\ncontract CometMath {\\n    /** Custom errors **/\\n\\n    error InvalidUInt64();\\n    error InvalidUInt104();\\n    error InvalidUInt128();\\n    error InvalidInt104();\\n    error InvalidInt256();\\n    error NegativeNumber();\\n\\n    function safe64(uint n) internal pure returns (uint64) {\\n        if (n > type(uint64).max) revert InvalidUInt64();\\n        return uint64(n);\\n    }\\n\\n    function safe104(uint n) internal pure returns (uint104) {\\n        if (n > type(uint104).max) revert InvalidUInt104();\\n        return uint104(n);\\n    }\\n\\n    function safe128(uint n) internal pure returns (uint128) {\\n        if (n > type(uint128).max) revert InvalidUInt128();\\n        return uint128(n);\\n    }\\n\\n    function signed104(uint104 n) internal pure returns (int104) {\\n        if (n > uint104(type(int104).max)) revert InvalidInt104();\\n        return int104(n);\\n    }\\n\\n    function signed256(uint256 n) internal pure returns (int256) {\\n        if (n > uint256(type(int256).max)) revert InvalidInt256();\\n        return int256(n);\\n    }\\n\\n    function unsigned104(int104 n) internal pure returns (uint104) {\\n        if (n < 0) revert NegativeNumber();\\n        return uint104(n);\\n    }\\n\\n    function unsigned256(int256 n) internal pure returns (uint256) {\\n        if (n < 0) revert NegativeNumber();\\n        return uint256(n);\\n    }\\n\\n    function toUInt8(bool x) internal pure returns (uint8) {\\n        return x ? 1 : 0;\\n    }\\n\\n    function toBool(uint8 x) internal pure returns (bool) {\\n        return x != 0;\\n    }\\n}\\n\",\"versionPragma\":\"0.8.20\"},\"contracts/protocols/compoundV3/CometStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/**\\n * @title Compound's Comet Storage Interface\\n * @dev Versions can enforce append-only storage slots via inheritance.\\n * @author Compound\\n */\\ncontract CometStorage {\\n    // 512 bits total = 2 slots\\n    struct TotalsBasic {\\n        // 1st slot\\n        uint64 baseSupplyIndex;\\n        uint64 baseBorrowIndex;\\n        uint64 trackingSupplyIndex;\\n        uint64 trackingBorrowIndex;\\n        // 2nd slot\\n        uint104 totalSupplyBase;\\n        uint104 totalBorrowBase;\\n        uint40 lastAccrualTime;\\n        uint8 pauseFlags;\\n    }\\n\\n    struct TotalsCollateral {\\n        uint128 totalSupplyAsset;\\n        uint128 _reserved;\\n    }\\n\\n    struct UserBasic {\\n        int104 principal;\\n        uint64 baseTrackingIndex;\\n        uint64 baseTrackingAccrued;\\n        uint16 assetsIn;\\n        uint8 _reserved;\\n    }\\n\\n    struct UserCollateral {\\n        uint128 balance;\\n        uint128 _reserved;\\n    }\\n\\n    struct LiquidatorPoints {\\n        uint32 numAbsorbs;\\n        uint64 numAbsorbed;\\n        uint128 approxSpend;\\n        uint32 _reserved;\\n    }\\n\\n    /// @dev Aggregate variables tracked for the entire market\\n    uint64 internal baseSupplyIndex;\\n    uint64 internal baseBorrowIndex;\\n    uint64 internal trackingSupplyIndex;\\n    uint64 internal trackingBorrowIndex;\\n    uint104 internal totalSupplyBase;\\n    uint104 internal totalBorrowBase;\\n    uint40 internal lastAccrualTime;\\n    uint8 internal pauseFlags;\\n\\n    /// @notice Aggregate variables tracked for each collateral asset\\n    mapping(address => TotalsCollateral) public totalsCollateral;\\n\\n    /// @notice Mapping of users to accounts which may be permitted to manage the user account\\n    mapping(address => mapping(address => bool)) public isAllowed;\\n\\n    /// @notice The next expected nonce for an address, for validating authorizations via signature\\n    mapping(address => uint) public userNonce;\\n\\n    /// @notice Mapping of users to base principal and other basic data\\n    mapping(address => UserBasic) public userBasic;\\n\\n    /// @notice Mapping of users to collateral data per collateral asset\\n    mapping(address => mapping(address => UserCollateral))\\n        public userCollateral;\\n\\n    /// @notice Mapping of magic liquidator points\\n    mapping(address => LiquidatorPoints) public liquidatorPoints;\\n}\\n\",\"versionPragma\":\"0.8.20\"},\"contracts/protocols/compoundV3/CometCore.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./CometConfiguration.sol\\\";\\nimport \\\"./CometStorage.sol\\\";\\nimport \\\"./CometMath.sol\\\";\\n\\nabstract contract CometCore is CometConfiguration, CometStorage, CometMath {\\n    struct AssetInfo {\\n        uint8 offset;\\n        address asset;\\n        address priceFeed;\\n        uint64 scale;\\n        uint64 borrowCollateralFactor;\\n        uint64 liquidateCollateralFactor;\\n        uint64 liquidationFactor;\\n        uint128 supplyCap;\\n    }\\n\\n    /** Internal constants **/\\n\\n    /// @dev The max number of assets this contract is hardcoded to support\\n    ///  Do not change this variable without updating all the fields throughout the contract,\\n    //    including the size of UserBasic.assetsIn and corresponding integer conversions.\\n    uint8 internal constant MAX_ASSETS = 15;\\n\\n    /// @dev The max number of decimals base token can have\\n    ///  Note this cannot just be increased arbitrarily.\\n    uint8 internal constant MAX_BASE_DECIMALS = 18;\\n\\n    /// @dev The max value for a collateral factor (1)\\n    uint64 internal constant MAX_COLLATERAL_FACTOR = FACTOR_SCALE;\\n\\n    /// @dev Offsets for specific actions in the pause flag bit array\\n    uint8 internal constant PAUSE_SUPPLY_OFFSET = 0;\\n    uint8 internal constant PAUSE_TRANSFER_OFFSET = 1;\\n    uint8 internal constant PAUSE_WITHDRAW_OFFSET = 2;\\n    uint8 internal constant PAUSE_ABSORB_OFFSET = 3;\\n    uint8 internal constant PAUSE_BUY_OFFSET = 4;\\n\\n    /// @dev The decimals required for a price feed\\n    uint8 internal constant PRICE_FEED_DECIMALS = 8;\\n\\n    /// @dev 365 days * 24 hours * 60 minutes * 60 seconds\\n    uint64 internal constant SECONDS_PER_YEAR = 31_536_000;\\n\\n    /// @dev The scale for base tracking accrual\\n    uint64 internal constant BASE_ACCRUAL_SCALE = 1e6;\\n\\n    /// @dev The scale for base index (depends on time/rate scales, not base token)\\n    uint64 internal constant BASE_INDEX_SCALE = 1e15;\\n\\n    /// @dev The scale for prices (in USD)\\n    uint64 internal constant PRICE_SCALE = uint64(10 ** PRICE_FEED_DECIMALS);\\n\\n    /// @dev The scale for factors\\n    uint64 internal constant FACTOR_SCALE = 1e18;\\n\\n    /**\\n     * @notice Determine if the manager has permission to act on behalf of the owner\\n     * @param owner The owner account\\n     * @param manager The manager account\\n     * @return Whether or not the manager has permission\\n     */\\n    function hasPermission(\\n        address owner,\\n        address manager\\n    ) public view returns (bool) {\\n        return owner == manager || isAllowed[owner][manager];\\n    }\\n\\n    /**\\n     * @dev The positive present supply balance if positive or the negative borrow balance if negative\\n     */\\n    function presentValue(\\n        int104 principalValue_\\n    ) internal view returns (int256) {\\n        if (principalValue_ >= 0) {\\n            return\\n                signed256(\\n                    presentValueSupply(\\n                        baseSupplyIndex,\\n                        uint104(principalValue_)\\n                    )\\n                );\\n        } else {\\n            return\\n                -signed256(\\n                    presentValueBorrow(\\n                        baseBorrowIndex,\\n                        uint104(-principalValue_)\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev The principal amount projected forward by the supply index\\n     */\\n    function presentValueSupply(\\n        uint64 baseSupplyIndex_,\\n        uint104 principalValue_\\n    ) internal pure returns (uint256) {\\n        return (uint256(principalValue_) * baseSupplyIndex_) / BASE_INDEX_SCALE;\\n    }\\n\\n    /**\\n     * @dev The principal amount projected forward by the borrow index\\n     */\\n    function presentValueBorrow(\\n        uint64 baseBorrowIndex_,\\n        uint104 principalValue_\\n    ) internal pure returns (uint256) {\\n        return (uint256(principalValue_) * baseBorrowIndex_) / BASE_INDEX_SCALE;\\n    }\\n\\n    /**\\n     * @dev The positive principal if positive or the negative principal if negative\\n     */\\n    function principalValue(\\n        int256 presentValue_\\n    ) internal view returns (int104) {\\n        if (presentValue_ >= 0) {\\n            return\\n                signed104(\\n                    principalValueSupply(\\n                        baseSupplyIndex,\\n                        uint256(presentValue_)\\n                    )\\n                );\\n        } else {\\n            return\\n                -signed104(\\n                    principalValueBorrow(\\n                        baseBorrowIndex,\\n                        uint256(-presentValue_)\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev The present value projected backward by the supply index (rounded down)\\n     *  Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\\n     */\\n    function principalValueSupply(\\n        uint64 baseSupplyIndex_,\\n        uint256 presentValue_\\n    ) internal pure returns (uint104) {\\n        return safe104((presentValue_ * BASE_INDEX_SCALE) / baseSupplyIndex_);\\n    }\\n\\n    /**\\n     * @dev The present value projected backward by the borrow index (rounded up)\\n     *  Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\\n     */\\n    function principalValueBorrow(\\n        uint64 baseBorrowIndex_,\\n        uint256 presentValue_\\n    ) internal pure returns (uint104) {\\n        return\\n            safe104(\\n                (presentValue_ * BASE_INDEX_SCALE + baseBorrowIndex_ - 1) /\\n                    baseBorrowIndex_\\n            );\\n    }\\n}\\n\",\"versionPragma\":\"0.8.20\"},\"contracts/protocols/compoundV3/CometMainInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./CometCore.sol\\\";\\n\\n/**\\n * @title Compound's Comet Main Interface (without Ext)\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\nabstract contract CometMainInterface is CometCore {\\n    error Absurd();\\n    error AlreadyInitialized();\\n    error BadAsset();\\n    error BadDecimals();\\n    error BadDiscount();\\n    error BadMinimum();\\n    error BadPrice();\\n    error BorrowTooSmall();\\n    error BorrowCFTooLarge();\\n    error InsufficientReserves();\\n    error LiquidateCFTooLarge();\\n    error NoSelfTransfer();\\n    error NotCollateralized();\\n    error NotForSale();\\n    error NotLiquidatable();\\n    error Paused();\\n    error SupplyCapExceeded();\\n    error TimestampTooLarge();\\n    error TooManyAssets();\\n    error TooMuchSlippage();\\n    error TransferInFailed();\\n    error TransferOutFailed();\\n    error Unauthorized();\\n\\n    event Supply(address indexed from, address indexed dst, uint amount);\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Withdraw(address indexed src, address indexed to, uint amount);\\n\\n    event SupplyCollateral(\\n        address indexed from,\\n        address indexed dst,\\n        address indexed asset,\\n        uint amount\\n    );\\n    event TransferCollateral(\\n        address indexed from,\\n        address indexed to,\\n        address indexed asset,\\n        uint amount\\n    );\\n    event WithdrawCollateral(\\n        address indexed src,\\n        address indexed to,\\n        address indexed asset,\\n        uint amount\\n    );\\n\\n    /// @notice Event emitted when a borrow position is absorbed by the protocol\\n    event AbsorbDebt(\\n        address indexed absorber,\\n        address indexed borrower,\\n        uint basePaidOut,\\n        uint usdValue\\n    );\\n\\n    /// @notice Event emitted when a user's collateral is absorbed by the protocol\\n    event AbsorbCollateral(\\n        address indexed absorber,\\n        address indexed borrower,\\n        address indexed asset,\\n        uint collateralAbsorbed,\\n        uint usdValue\\n    );\\n\\n    /// @notice Event emitted when a collateral asset is purchased from the protocol\\n    event BuyCollateral(\\n        address indexed buyer,\\n        address indexed asset,\\n        uint baseAmount,\\n        uint collateralAmount\\n    );\\n\\n    /// @notice Event emitted when an action is paused/unpaused\\n    event PauseAction(\\n        bool supplyPaused,\\n        bool transferPaused,\\n        bool withdrawPaused,\\n        bool absorbPaused,\\n        bool buyPaused\\n    );\\n\\n    /// @notice Event emitted when reserves are withdrawn by the governor\\n    event WithdrawReserves(address indexed to, uint amount);\\n\\n    function supply(address asset, uint amount) external virtual;\\n\\n    function supplyTo(address dst, address asset, uint amount) external virtual;\\n\\n    function supplyFrom(\\n        address from,\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function transfer(address dst, uint amount) external virtual returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint amount\\n    ) external virtual returns (bool);\\n\\n    function transferAsset(\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function transferAssetFrom(\\n        address src,\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function withdraw(address asset, uint amount) external virtual;\\n\\n    function withdrawTo(\\n        address to,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function withdrawFrom(\\n        address src,\\n        address to,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function approveThis(\\n        address manager,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function withdrawReserves(address to, uint amount) external virtual;\\n\\n    function absorb(\\n        address absorber,\\n        address[] calldata accounts\\n    ) external virtual;\\n\\n    function buyCollateral(\\n        address asset,\\n        uint minAmount,\\n        uint baseAmount,\\n        address recipient\\n    ) external virtual;\\n\\n    function quoteCollateral(\\n        address asset,\\n        uint baseAmount\\n    ) public view virtual returns (uint);\\n\\n    function getAssetInfo(\\n        uint8 i\\n    ) public view virtual returns (AssetInfo memory);\\n\\n    function getAssetInfoByAddress(\\n        address asset\\n    ) public view virtual returns (AssetInfo memory);\\n\\n    function getCollateralReserves(\\n        address asset\\n    ) public view virtual returns (uint);\\n\\n    function getReserves() public view virtual returns (int);\\n\\n    function getPrice(address priceFeed) public view virtual returns (uint);\\n\\n    function isBorrowCollateralized(\\n        address account\\n    ) public view virtual returns (bool);\\n\\n    function isLiquidatable(address account) public view virtual returns (bool);\\n\\n    function totalSupply() external view virtual returns (uint256);\\n\\n    function totalBorrow() external view virtual returns (uint256);\\n\\n    function balanceOf(address owner) public view virtual returns (uint256);\\n\\n    function borrowBalanceOf(\\n        address account\\n    ) public view virtual returns (uint256);\\n\\n    function pause(\\n        bool supplyPaused,\\n        bool transferPaused,\\n        bool withdrawPaused,\\n        bool absorbPaused,\\n        bool buyPaused\\n    ) external virtual;\\n\\n    function isSupplyPaused() public view virtual returns (bool);\\n\\n    function isTransferPaused() public view virtual returns (bool);\\n\\n    function isWithdrawPaused() public view virtual returns (bool);\\n\\n    function isAbsorbPaused() public view virtual returns (bool);\\n\\n    function isBuyPaused() public view virtual returns (bool);\\n\\n    function accrueAccount(address account) external virtual;\\n\\n    function getSupplyRate(\\n        uint utilization\\n    ) public view virtual returns (uint64);\\n\\n    function getBorrowRate(\\n        uint utilization\\n    ) public view virtual returns (uint64);\\n\\n    function getUtilization() public view virtual returns (uint);\\n\\n    function governor() external view virtual returns (address);\\n\\n    function pauseGuardian() external view virtual returns (address);\\n\\n    function baseToken() external view virtual returns (address);\\n\\n    function baseTokenPriceFeed() external view virtual returns (address);\\n\\n    function extensionDelegate() external view virtual returns (address);\\n\\n    /// @dev uint64\\n    function supplyKink() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateSlopeLow()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateSlopeHigh()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateBase()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function borrowKink() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateSlopeLow()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateSlopeHigh()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateBase()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function storeFrontPriceFactor() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function baseScale() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function trackingIndexScale() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function baseTrackingSupplySpeed() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function baseTrackingBorrowSpeed() external view virtual returns (uint);\\n\\n    /// @dev uint104\\n    function baseMinForRewards() external view virtual returns (uint);\\n\\n    /// @dev uint104\\n    function baseBorrowMin() external view virtual returns (uint);\\n\\n    /// @dev uint104\\n    function targetReserves() external view virtual returns (uint);\\n\\n    function numAssets() external view virtual returns (uint8);\\n\\n    function decimals() external view virtual returns (uint8);\\n\\n    function initializeStorage() external virtual;\\n}\\n\",\"versionPragma\":\"0.8.20\"},\"contracts/modules/CompoundV3Reinvest.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../protocols/compoundV3/CometMainInterface.sol\\\";\\nimport {ReinvestCodes} from \\\"../library/Codes.sol\\\";\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *       Dollar Cost Average Contracts\\n ************************************************\\n *                  V0.6\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\nlibrary CompoundV3Reinvest {\\n    string public constant MODULE_NAME = \\\"Compound V3 Reinvest\\\";\\n    uint8 public constant MODULE_ID = 0x11;\\n\\n    address internal constant COMPOUND_ETH_CONTRACT =\\n        0x46e6b214b524310239732D51387075E0e70970bf; // BASE\\n\\n    uint8 constant WETH = 0x0;\\n    uint8 constant USDC = 0x1;\\n    struct ReinvestDataStruct {\\n        uint8 moduleCode;\\n        address receiver;\\n        address token;\\n    }\\n\\n    function _execute(\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal returns (uint256 amount, bool success) {\\n        ReinvestDataStruct memory investData = _decodeData(data_);\\n\\n        amount = _supplyCompound(\\n            investData.moduleCode,\\n            amount_,\\n            investData.token\\n        );\\n\\n        if (amount > 0) success = true;\\n\\n        return (amount, success);\\n    }\\n\\n    function _unwind(\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal returns (uint256 amount, bool success) {\\n        ReinvestDataStruct memory investData = _decodeData(data_);\\n\\n        amount = _withdrawCompound(\\n            investData.moduleCode,\\n            amount_,\\n            investData.token\\n        );\\n\\n        if (amount > 0) success = true;\\n\\n        return (amount, success);\\n    }\\n\\n    function _supplyCompound(\\n        uint8 code_,\\n        uint256 amount_,\\n        address tokenAddress_\\n    ) internal returns (uint256 amount) {\\n        address compoundContract = _getContractAddress(code_);\\n        uint256 oldBalance = _getBalance(tokenAddress_, compoundContract);\\n\\n        // Approve the reinvest contract to spend the given token.\\n        // Check that the approval worked\\n        bool allowed = IERC20(tokenAddress_).approve(compoundContract, amount_);\\n        require(allowed, \\\"DCAAccount : [Compound Reinvest] - Approval failed\\\");\\n\\n        // If it worked, then supply that token\\n        // Check that we have recieved some tokens.\\n        CometMainInterface(compoundContract).supply(tokenAddress_, amount_);\\n        amount = _getBalance(tokenAddress_, compoundContract) - (oldBalance);\\n        return amount;\\n    }\\n\\n    function _withdrawCompound(\\n        uint8 code_,\\n        uint256 amount_,\\n        address tokenAddress_\\n    ) internal returns (uint256 amount) {\\n        address compoundContract = _getContractAddress(code_);\\n        uint256 oldBalance = _getBalance(tokenAddress_, compoundContract);\\n\\n        CometMainInterface(compoundContract).withdraw(tokenAddress_, amount_);\\n        amount = oldBalance - (_getBalance(tokenAddress_, compoundContract));\\n        return (amount);\\n    }\\n\\n    function _getContractAddress(uint8 code_) internal pure returns (address) {\\n        if (code_ == WETH) return COMPOUND_ETH_CONTRACT;\\n    }\\n\\n    function _getBalance(\\n        address tokenAddress_,\\n        address pool_\\n    ) internal returns (uint256 amount) {\\n        amount = CometMainInterface(pool_).balanceOf(address(this));\\n    }\\n\\n    function _withdrawReward(\\n        uint8 code_,\\n        uint256 amount_,\\n        address tokenAddress_\\n    ) internal returns (uint256 amount) {}\\n\\n    function _decodeData(\\n        bytes memory data_\\n    ) private pure returns (ReinvestDataStruct memory) {\\n        return abi.decode(data_, (ReinvestDataStruct));\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/interfaces/IDCADataStructures.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *      Distributed Cost Average Contracts\\n ************************************************\\n *                  V0.7\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\ninterface IDCADataStructures {\\n    /**\\n     * @notice List of available intervals for executions\\n     * @notice Timing will be in seconds\\n     * @dev Check agenst Executor if the strategy interval is active\\n     */\\n    enum Interval {\\n        TestIntervalOneMin, //Only for development\\n        TestIntervalFiveMins, //Only for development\\n        OneDay,\\n        TwoDays,\\n        ThreeDays,\\n        OneWeek,\\n        TwoWeeks,\\n        OneMonth\\n    }\\n\\n    /**\\n     * @notice The fee distribution struct\\n     * @dev Working by a factor of 100 (100% = 10000)\\n     * @dev Executor, Computing and Admin fees should add up to 100%\\n     * @param amountToExecutor Percent of the FEE going to Executor EOA\\n     * @param amountToComputing Percent of the FEE going to Executor Computing costs\\n     * @param amountToAdmin Percent of the FEE going to admin\\n     * @param feeAmount Total amount of the pre-execution to be taken as fee\\n     * @param executionAddress The address of the executor\\n     * @param computingAddress The address of the computing\\n     * @param adminAddress The address of the admin\\n     */\\n    struct FeeDistribution {\\n        uint16 amountToExecutor; //In percent (where 10000 = 100%, 100 = 1%, etc.)\\n        uint16 amountToComputing; //In percent (where 10000 = 100%, 100 = 1%, etc.)\\n        uint16 amountToAdmin; //In percent (where 10000 = 100%, 100 = 1%, etc.)\\n        uint16 feeAmount; //In percent\\n        address executionAddress;\\n        address computingAddress; //need to look into how distributed computing payments work\\n        address adminAddress;\\n    }\\n\\n    /**\\n     * @notice The data struct defining the DCA Strategy\\n     * @param accountAddress Address of the account the strategy belongs to\\n     * @param baseToken The base token data\\n     * @param targetToken The target token data\\n     * @param interval The interval for the strategy\\n     * @param amount The amount of the base token to invest each interval\\n     * @param strategyId The ID of the strategy\\n     * @param active Whether the strategy is active\\n     * @param reinvest The reinvest data\\n     *\\n     * @dev strategyId is assigned by the account contract\\n     *\\n     */\\n    struct Strategy {\\n        address accountAddress;\\n        TokenData baseToken;\\n        TokenData targetToken; //use 0x0 for ETH\\n        Interval interval;\\n        uint256 amount;\\n        uint256 strategyId;\\n        bool active;\\n        Reinvest reinvest;\\n    }\\n\\n    /**\\n     *  @notice Token Data struct\\n     * @param tokenAddress The address of the token (i using native token use zero address address(0x0))\\n     * @param decimals The amount of decimals the token uses\\n     * @param ticker Of the token\\n     */\\n    struct TokenData {\\n        address tokenAddress;\\n        uint8 decimals;\\n        string ticker;\\n    }\\n\\n    /**\\n     * @notice Reinvest strategy struct.\\n     * If no reinvest set active to false and zero-out other fields\\n     * If using predefined reinvest strategy zero-out the bytes fields\\n     * Check code agents the Reinvest Codes library\\n     *\\n     * @notice deposit & withdraw reinvest methods only needed IF using custom reinvest strategy\\n     *\\n     * @param reinvestData Reinvest strategy specific data (encoded to bytes)\\n     * @param active If the reinvest is active\\n     * @param investCode Reinvest strategy code\\n     * @param dcaAccountAddress address of the account contract\\n     */\\n\\n    struct Reinvest {\\n        bytes reinvestData;\\n        bool active;\\n        uint8 investCode;\\n        address dcaAccountAddress;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/interfaces/IDCAReinvest.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {IDCADataStructures} from \\\"./IDCADataStructures.sol\\\";\\n\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *      Distributed Cost Average Contracts\\n ************************************************\\n *                  V0.7\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\ninterface IDCAReinvest {\\n    /**\\n     * @dev Executes the reinvestment\\n     * @param reinvestData_ The reinvestment data\\n     * @param amount_ The amount to reinvest\\n     * @return amount The amount of the reinvestment\\n     * @return success The success of the reinvestment\\n     */\\n    function executeReinvest(\\n        IDCADataStructures.Reinvest memory reinvestData_,\\n        uint256 amount_\\n    ) external returns (uint256 amount, bool success);\\n\\n    /**\\n     * @dev Unwinds the reinvestment\\n     * @param reinvestData_ The reinvestment data\\n     * @param amount_ The amount to unwind\\n     * @return amount The amount of the unwind\\n     * @return success The success of the unwind\\n     */\\n    function unwindReinvest(\\n        IDCADataStructures.Reinvest memory reinvestData_,\\n        uint256 amount_\\n    ) external returns (uint256 amount, bool success);\\n\\n    /**\\n     * @dev Checks if the reinvestment is active\\n     * @return isActive Whether the reinvestment is active\\n     */\\n    function isActive() external view returns (bool);\\n\\n    /**\\n     * @dev Returns the version of the reinvestment\\n     * @return The version of the reinvestment\\n     */\\n    function getLibraryVersion() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the active moduals\\n     * @return The active moduals\\n     */\\n    function getActiveModuals() external view returns (uint8[] memory);\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/logic/ReinvestLogic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n//DEV\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../library/Codes.sol\\\";\\n\\nimport {IDCAReinvest, IDCADataStructures} from \\\"../interfaces/IDCAReinvest.sol\\\";\\n\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *      Distributed Cost Average Contracts\\n ************************************************\\n *                  V0.7\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\n\\nabstract contract DCAReinvestLogic is IDCAReinvest {\\n    using ReinvestCodes for uint8;\\n    string public constant REINVEST_VERSION = \\\"TEST V0.6\\\";\\n    bytes public constant ACTIVE_REINVESTS =\\n        abi.encodePacked(\\n            ReinvestCodes.FORWARD,\\n            ReinvestCodes.AAVE,\\n            ReinvestCodes.COMPOUND\\n        );\\n\\n    /**\\n     * @dev Executes the reinvestment\\n     * @param reinvestData_ {Reinvest} Data of the reinvest strategy\\n     * @param amount_ {uint256} amount of the token to be invested\\n     * @return amount {uint256} the amount of the yield baring token recived\\n     */\\n\\n    function _executeInvest(\\n        IDCADataStructures.Reinvest memory reinvestData_,\\n        uint256 amount_\\n    ) internal returns (uint256 amount, bool success) {\\n        uint8 code = reinvestData_.investCode;\\n\\n        if (code.checkCode(ReinvestCodes.NOT_ACTIVE)) return (amount, success);\\n        else if (code.checkCode(ReinvestCodes.FORWARD))\\n            return\\n                ForwardReinvest._execute(amount_, reinvestData_.reinvestData);\\n        else if (code.checkCode(ReinvestCodes.COMPOUND))\\n            return\\n                CompoundV3Reinvest._execute(\\n                    amount_,\\n                    reinvestData_.reinvestData\\n                );\\n        else if (code == ReinvestCodes.AAVE)\\n            return AaveV3Reinvest._execute(amount_, reinvestData_.reinvestData);\\n    }\\n\\n    /**\\n     * @dev Executes the unwind of the reinvestment\\n     * @param reinvestData_ The reinvestment data\\n     * @param amount_ The amount to unwind\\n     * @return amount The amount of the unwind\\n     * @return success The success of the unwind\\n     */\\n    function _executeWithdraw(\\n        IDCADataStructures.Reinvest memory reinvestData_,\\n        uint256 amount_\\n    ) internal returns (uint256 amount, bool success) {\\n        if (reinvestData_.investCode <= ReinvestCodes.COMPOUND) {\\n            return\\n                CompoundV3Reinvest._unwind(amount_, reinvestData_.reinvestData);\\n        } else if (reinvestData_.investCode == ReinvestCodes.AAVE)\\n            return AaveV3Reinvest._unwind(amount_, reinvestData_.reinvestData);\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/security/onlyActive.sol\":{\"content\":\"pragma solidity ^0.8.20;\\n\\n/**\\n *\\n ************************************************\\n *____ooo____oooooooo_oooo____oooo____ooo____oo_*\\n *__oo___oo_____oo_____oo___oo____oo__oooo___oo_*\\n *_oo_____oo____oo_____oo__oo______oo_oo_oo__oo_*\\n *_ooooooooo____oo_____oo__oo______oo_oo__oo_oo_*\\n *_oo_____oo____oo_____oo___oo____oo__oo___oooo_*\\n *_oo_____oo____oo____oooo____oooo____oo____ooo_*\\n *______________________________________________*\\n *       Dollar Cost Average Contracts\\n ************************************************\\n *                  V0.6\\n *  x.com/0xAtion\\n *  x.com/e_labs_\\n *  e-labs.co.uk\\n *\\n */\\nabstract contract OnlyActive {\\n    /**\\n     * @notice The active state of the contract\\n     */\\n    bool private _active = true;\\n\\n    /**\\n     * @notice Emitted when the active state of the contract is changed\\n     * @param active_ The new active state\\n     */\\n    event ContractActiveStateChange(bool indexed active_);\\n\\n    /**\\n     * @notice Error thrown when the contract is paused\\n     */\\n    error ContractIsPaused();\\n\\n    /**\\n     * @notice Modifier to check if the contract is active\\n     */\\n    modifier is_active() {\\n        if (!_active) revert ContractIsPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the active state of the contract\\n     * @return isActive True if the contract is active, false otherwise\\n     */\\n    function isActive() external view virtual returns (bool) {\\n        return _active;\\n    }\\n\\n    /**\\n     * @notice Sets the active state of the contract\\n     * @param active_ The new active state\\n     */\\n    function _setActiveState(bool active_) internal {\\n        _active = active_;\\n        emit ContractActiveStateChange(active_);\\n    }\\n\\n    /**\\n     * @notice Returns the active state of the contract\\n     * @return True if the contract is active, false otherwise\\n     */\\n    function _getActiveState() internal view returns (bool) {\\n        return _active;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"}}}","address":"0x98e3aef4a039Dcc7298b7FeEFe03c6c2B1Fc3cBB","bytecode":"0x60806040526000805460ff191660011790553480156200001e57600080fd5b50604051620016d8380380620016d883398101604081905262000041916200011a565b33806200006857604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b620000738162000086565b506200007f81620000df565b5062000145565b600080546001600160a01b03838116610100818102610100600160a81b0319851617855560405193049190911692909183917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a35050565b6000805460ff1916821515908117825560405190917fbdf1a3ee1d5eb15aa60ae1a81488107759732ead44999c8c807575100def058b91a250565b6000602082840312156200012d57600080fd5b815180151581146200013e57600080fd5b9392505050565b61158380620001556000396000f3fe608060405234801561001057600080fd5b50600436106100d45760003560e01c80638da5cb5b11610081578063c7b785e81161005b578063c7b785e81461021b578063c9f6d48f1461022e578063f2fde38b146102bb57600080fd5b80638da5cb5b146101b0578063bcb9236e146101f3578063c445d2ea1461020657600080fd5b8063454f002a116100b2578063454f002a14610144578063715018a61461016c578063738800b71461017457600080fd5b80630ca75044146100d957806322f3e2d41461012457806340438aea1461013a575b600080fd5b60408051808201909152600981527f544553542056302e36000000000000000000000000000000000000000000000060208201525b60405161011b91906110e6565b60405180910390f35b60005460ff16604051901515815260200161011b565b6101426102d3565b005b610157610152366004611200565b6102f2565b6040805192835290151560208301520161011b565b610142610347565b61010e6040518060400160405280600981526020017f544553542056302e36000000000000000000000000000000000000000000000081525081565b600054610100900473ffffffffffffffffffffffffffffffffffffffff1660405173ffffffffffffffffffffffffffffffffffffffff909116815260200161011b565b610157610201366004611200565b610359565b61020e610366565b60405161011b9190611316565b61010e61022936600461135d565b610403565b61010e6040517f010000000000000000000000000000000000000000000000000000000000000060208201527f120000000000000000000000000000000000000000000000000000000000000060218201527f1100000000000000000000000000000000000000000000000000000000000000602282015260230160405160208183030381529060405281565b6101426102c936600461137a565b610417565b905090565b6102db610480565b6102f06102ea60005460ff1690565b156104d9565b565b60008054819060ff16610331576040517f6d39fcd000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61033b8484610532565b915091505b9250929050565b61034f610480565b6102f060006105c6565b60008061033b8484610643565b6040517f010000000000000000000000000000000000000000000000000000000000000060208201527f120000000000000000000000000000000000000000000000000000000000000060218201527f110000000000000000000000000000000000000000000000000000000000000060228201526060906023016040516020818303038152906040528060200190518101906102ce9190611397565b60606104118260ff1661068f565b92915050565b61041f610480565b73ffffffffffffffffffffffffffffffffffffffff8116610474576040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600060048201526024015b60405180910390fd5b61047d816105c6565b50565b60005473ffffffffffffffffffffffffffffffffffffffff6101009091041633146102f0576040517f118cdaa700000000000000000000000000000000000000000000000000000000815233600482015260240161046b565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016821515908117825560405190917fbdf1a3ee1d5eb15aa60ae1a81488107759732ead44999c8c807575100def058b91a250565b6040820151600090819060ff811661054a5750610340565b600160ff82160361056d576105638486600001516107a0565b9250925050610340565b601160ff821603610586576105638486600001516108ea565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee60ff8216016105be57610563848660000151610921565b509250929050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381166101008181027fffffffffffffffffffffff0000000000000000000000000000000000000000ff851617855560405193049190911692909183917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a35050565b600080601160ff16846040015160ff161161066f57610666838560000151610bea565b91509150610340565b601260ff16846040015160ff160361034057610666838560000151610c0d565b606060ff82166106d257505060408051808201909152600a81527f4e6f742041637469766500000000000000000000000000000000000000000000602082015290565b60ff821660010361071657505060408051808201909152601581527f466f7277617264205265696e766573742056302e320000000000000000000000602082015290565b60ff821660120361075a57505060408051808201909152601081527f41617665205633205265696e7665737400000000000000000000000000000000602082015290565b60ff821660110361079b575060408051808201909152601481527f436f6d706f756e64205633205265696e7665737400000000000000000000000060208201525b919050565b60008060006107ae84610ce2565b604081015190915073ffffffffffffffffffffffffffffffffffffffff1661083c57806020015173ffffffffffffffffffffffffffffffffffffffff168560405160006040518083038185875af1925050503d806000811461082c576040519150601f19603f3d011682016040523d82523d6000602084013e610831565b606091505b5050809250506108e2565b604080820151602083015191517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff92831660048201526024810188905291169063a9059cbb906044016020604051808303816000875af11580156108bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108df9190611449565b91505b509293915050565b60008060006108f884610ce2565b905061090d8160000151868360400151610d11565b925082156105be5760019150509250929050565b600080600061092f84610ce2565b60408082015190517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015291925060009173ffffffffffffffffffffffffffffffffffffffff909116906370a0823190602401602060405180830381865afa1580156109a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109c99190611466565b60208301516040517f095ea7b300000000000000000000000000000000000000000000000000000000815273a238dd80c259a72e81d7e4664a9801593f98d1c560048201526024810189905291925060009173ffffffffffffffffffffffffffffffffffffffff9091169063095ea7b3906044016020604051808303816000875af1158015610a5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a809190611449565b90508015610be05760208301516040517f617ba03700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602481018890523060448201526000606482015273a238dd80c259a72e81d7e4664a9801593f98d1c59063617ba03790608401600060405180830381600087803b158015610b1d57600080fd5b505af1158015610b31573d6000803e3d6000fd5b5050505060408381015190517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009173ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa158015610ba6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bca9190611466565b9050610bd6838261147f565b9550600086119450505b5050509250929050565b6000806000610bf884610ce2565b905061090d8160000151868360400151610f01565b6000806000610c1b84610ce2565b60208101516040517f69328dec00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff90911660048201526024810187905230604482015290915073a238dd80c259a72e81d7e4664a9801593f98d1c5906369328dec906064016020604051808303816000875af1158015610cb1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd59190611466565b9586151595509350505050565b604080516060810182526000808252602080830182905292820152825190916104119184018101908401611531565b600080610d1d85610fc5565b90506000610d2b8483610fea565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84811660048301526024820188905291925060009186169063095ea7b3906044016020604051808303816000875af1158015610da6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dca9190611449565b905080610e59576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f4443414163636f756e74203a205b436f6d706f756e64205265696e766573745d60448201527f202d20417070726f76616c206661696c65640000000000000000000000000000606482015260840161046b565b6040517ff2b9fdb800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301526024820188905284169063f2b9fdb890604401600060405180830381600087803b158015610ec957600080fd5b505af1158015610edd573d6000803e3d6000fd5b5050505081610eec8685610fea565b610ef6919061147f565b979650505050505050565b600080610f0d85610fc5565b90506000610f1b8483610fea565b6040517ff3fef3a300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8681166004830152602482018890529192509083169063f3fef3a390604401600060405180830381600087803b158015610f8f57600080fd5b505af1158015610fa3573d6000803e3d6000fd5b50505050610fb18483610fea565b610fbb908261147f565b9695505050505050565b600060ff821661079b57507346e6b214b524310239732d51387075e0e70970bf919050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff8316906370a0823190602401602060405180830381865afa158015611057573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061107b9190611466565b9392505050565b6000815180845260005b818110156110a85760208185018101518683018201520161108c565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b60208152600061107b6020830184611082565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516080810167ffffffffffffffff8111828210171561114b5761114b6110f9565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611198576111986110f9565b604052919050565b801515811461047d57600080fd5b803561079b816111a0565b60ff8116811461047d57600080fd5b803561079b816111b9565b73ffffffffffffffffffffffffffffffffffffffff8116811461047d57600080fd5b803561079b816111d3565b6000806040838503121561121357600080fd5b823567ffffffffffffffff8082111561122b57600080fd5b908401906080828703121561123f57600080fd5b611247611128565b82358281111561125657600080fd5b8301601f8101881361126757600080fd5b803560208482111561127b5761127b6110f9565b6112ab817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f85011601611151565b945081855289818385010111156112c157600080fd5b818184018287013760008183870101528484526112df8187016111ae565b818501526112ef604087016111c8565b6040850152611300606087016111f5565b6060850152929997909201359750505050505050565b6020808252825182820181905260009190848201906040850190845b8181101561135157835160ff1683529284019291840191600101611332565b50909695505050505050565b60006020828403121561136f57600080fd5b813561107b816111b9565b60006020828403121561138c57600080fd5b813561107b816111d3565b600060208083850312156113aa57600080fd5b825167ffffffffffffffff808211156113c257600080fd5b818501915085601f8301126113d657600080fd5b8151818111156113e8576113e86110f9565b8060051b91506113f9848301611151565b818152918301840191848101908884111561141357600080fd5b938501935b8385101561143d578451925061142d836111b9565b8282529385019390850190611418565b98975050505050505050565b60006020828403121561145b57600080fd5b815161107b816111a0565b60006020828403121561147857600080fd5b5051919050565b81810381811115610411577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000606082840312156114cb57600080fd5b6040516060810181811067ffffffffffffffff821117156114ee576114ee6110f9565b80604052508091508251611501816111b9565b81526020830151611511816111d3565b60208201526040830151611524816111d3565b6040919091015292915050565b60006060828403121561154357600080fd5b61107b83836114b956fea264697066735822122039d5599aac5e3758b1d2b2b06f9a7445ae5d157539cf690cf416e87ffbe987ba64736f6c63430008140033","deployedBytecode":"0x608060405234801561001057600080fd5b50600436106100d45760003560e01c80638da5cb5b11610081578063c7b785e81161005b578063c7b785e81461021b578063c9f6d48f1461022e578063f2fde38b146102bb57600080fd5b80638da5cb5b146101b0578063bcb9236e146101f3578063c445d2ea1461020657600080fd5b8063454f002a116100b2578063454f002a14610144578063715018a61461016c578063738800b71461017457600080fd5b80630ca75044146100d957806322f3e2d41461012457806340438aea1461013a575b600080fd5b60408051808201909152600981527f544553542056302e36000000000000000000000000000000000000000000000060208201525b60405161011b91906110e6565b60405180910390f35b60005460ff16604051901515815260200161011b565b6101426102d3565b005b610157610152366004611200565b6102f2565b6040805192835290151560208301520161011b565b610142610347565b61010e6040518060400160405280600981526020017f544553542056302e36000000000000000000000000000000000000000000000081525081565b600054610100900473ffffffffffffffffffffffffffffffffffffffff1660405173ffffffffffffffffffffffffffffffffffffffff909116815260200161011b565b610157610201366004611200565b610359565b61020e610366565b60405161011b9190611316565b61010e61022936600461135d565b610403565b61010e6040517f010000000000000000000000000000000000000000000000000000000000000060208201527f120000000000000000000000000000000000000000000000000000000000000060218201527f1100000000000000000000000000000000000000000000000000000000000000602282015260230160405160208183030381529060405281565b6101426102c936600461137a565b610417565b905090565b6102db610480565b6102f06102ea60005460ff1690565b156104d9565b565b60008054819060ff16610331576040517f6d39fcd000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61033b8484610532565b915091505b9250929050565b61034f610480565b6102f060006105c6565b60008061033b8484610643565b6040517f010000000000000000000000000000000000000000000000000000000000000060208201527f120000000000000000000000000000000000000000000000000000000000000060218201527f110000000000000000000000000000000000000000000000000000000000000060228201526060906023016040516020818303038152906040528060200190518101906102ce9190611397565b60606104118260ff1661068f565b92915050565b61041f610480565b73ffffffffffffffffffffffffffffffffffffffff8116610474576040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600060048201526024015b60405180910390fd5b61047d816105c6565b50565b60005473ffffffffffffffffffffffffffffffffffffffff6101009091041633146102f0576040517f118cdaa700000000000000000000000000000000000000000000000000000000815233600482015260240161046b565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016821515908117825560405190917fbdf1a3ee1d5eb15aa60ae1a81488107759732ead44999c8c807575100def058b91a250565b6040820151600090819060ff811661054a5750610340565b600160ff82160361056d576105638486600001516107a0565b9250925050610340565b601160ff821603610586576105638486600001516108ea565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee60ff8216016105be57610563848660000151610921565b509250929050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381166101008181027fffffffffffffffffffffff0000000000000000000000000000000000000000ff851617855560405193049190911692909183917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a35050565b600080601160ff16846040015160ff161161066f57610666838560000151610bea565b91509150610340565b601260ff16846040015160ff160361034057610666838560000151610c0d565b606060ff82166106d257505060408051808201909152600a81527f4e6f742041637469766500000000000000000000000000000000000000000000602082015290565b60ff821660010361071657505060408051808201909152601581527f466f7277617264205265696e766573742056302e320000000000000000000000602082015290565b60ff821660120361075a57505060408051808201909152601081527f41617665205633205265696e7665737400000000000000000000000000000000602082015290565b60ff821660110361079b575060408051808201909152601481527f436f6d706f756e64205633205265696e7665737400000000000000000000000060208201525b919050565b60008060006107ae84610ce2565b604081015190915073ffffffffffffffffffffffffffffffffffffffff1661083c57806020015173ffffffffffffffffffffffffffffffffffffffff168560405160006040518083038185875af1925050503d806000811461082c576040519150601f19603f3d011682016040523d82523d6000602084013e610831565b606091505b5050809250506108e2565b604080820151602083015191517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff92831660048201526024810188905291169063a9059cbb906044016020604051808303816000875af11580156108bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108df9190611449565b91505b509293915050565b60008060006108f884610ce2565b905061090d8160000151868360400151610d11565b925082156105be5760019150509250929050565b600080600061092f84610ce2565b60408082015190517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015291925060009173ffffffffffffffffffffffffffffffffffffffff909116906370a0823190602401602060405180830381865afa1580156109a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109c99190611466565b60208301516040517f095ea7b300000000000000000000000000000000000000000000000000000000815273a238dd80c259a72e81d7e4664a9801593f98d1c560048201526024810189905291925060009173ffffffffffffffffffffffffffffffffffffffff9091169063095ea7b3906044016020604051808303816000875af1158015610a5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a809190611449565b90508015610be05760208301516040517f617ba03700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602481018890523060448201526000606482015273a238dd80c259a72e81d7e4664a9801593f98d1c59063617ba03790608401600060405180830381600087803b158015610b1d57600080fd5b505af1158015610b31573d6000803e3d6000fd5b5050505060408381015190517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009173ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa158015610ba6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bca9190611466565b9050610bd6838261147f565b9550600086119450505b5050509250929050565b6000806000610bf884610ce2565b905061090d8160000151868360400151610f01565b6000806000610c1b84610ce2565b60208101516040517f69328dec00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff90911660048201526024810187905230604482015290915073a238dd80c259a72e81d7e4664a9801593f98d1c5906369328dec906064016020604051808303816000875af1158015610cb1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd59190611466565b9586151595509350505050565b604080516060810182526000808252602080830182905292820152825190916104119184018101908401611531565b600080610d1d85610fc5565b90506000610d2b8483610fea565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84811660048301526024820188905291925060009186169063095ea7b3906044016020604051808303816000875af1158015610da6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dca9190611449565b905080610e59576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f4443414163636f756e74203a205b436f6d706f756e64205265696e766573745d60448201527f202d20417070726f76616c206661696c65640000000000000000000000000000606482015260840161046b565b6040517ff2b9fdb800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301526024820188905284169063f2b9fdb890604401600060405180830381600087803b158015610ec957600080fd5b505af1158015610edd573d6000803e3d6000fd5b5050505081610eec8685610fea565b610ef6919061147f565b979650505050505050565b600080610f0d85610fc5565b90506000610f1b8483610fea565b6040517ff3fef3a300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8681166004830152602482018890529192509083169063f3fef3a390604401600060405180830381600087803b158015610f8f57600080fd5b505af1158015610fa3573d6000803e3d6000fd5b50505050610fb18483610fea565b610fbb908261147f565b9695505050505050565b600060ff821661079b57507346e6b214b524310239732d51387075e0e70970bf919050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff8316906370a0823190602401602060405180830381865afa158015611057573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061107b9190611466565b9392505050565b6000815180845260005b818110156110a85760208185018101518683018201520161108c565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b60208152600061107b6020830184611082565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516080810167ffffffffffffffff8111828210171561114b5761114b6110f9565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611198576111986110f9565b604052919050565b801515811461047d57600080fd5b803561079b816111a0565b60ff8116811461047d57600080fd5b803561079b816111b9565b73ffffffffffffffffffffffffffffffffffffffff8116811461047d57600080fd5b803561079b816111d3565b6000806040838503121561121357600080fd5b823567ffffffffffffffff8082111561122b57600080fd5b908401906080828703121561123f57600080fd5b611247611128565b82358281111561125657600080fd5b8301601f8101881361126757600080fd5b803560208482111561127b5761127b6110f9565b6112ab817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f85011601611151565b945081855289818385010111156112c157600080fd5b818184018287013760008183870101528484526112df8187016111ae565b818501526112ef604087016111c8565b6040850152611300606087016111f5565b6060850152929997909201359750505050505050565b6020808252825182820181905260009190848201906040850190845b8181101561135157835160ff1683529284019291840191600101611332565b50909695505050505050565b60006020828403121561136f57600080fd5b813561107b816111b9565b60006020828403121561138c57600080fd5b813561107b816111d3565b600060208083850312156113aa57600080fd5b825167ffffffffffffffff808211156113c257600080fd5b818501915085601f8301126113d657600080fd5b8151818111156113e8576113e86110f9565b8060051b91506113f9848301611151565b818152918301840191848101908884111561141357600080fd5b938501935b8385101561143d578451925061142d836111b9565b8282529385019390850190611418565b98975050505050505050565b60006020828403121561145b57600080fd5b815161107b816111a0565b60006020828403121561147857600080fd5b5051919050565b81810381811115610411577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000606082840312156114cb57600080fd5b6040516060810181811067ffffffffffffffff821117156114ee576114ee6110f9565b80604052508091508251611501816111b9565b81526020830151611511816111d3565b60208201526040830151611524816111d3565b6040919091015292915050565b60006060828403121561154357600080fd5b61107b83836114b956fea264697066735822122039d5599aac5e3758b1d2b2b06f9a7445ae5d157539cf690cf416e87ffbe987ba64736f6c63430008140033","abi":[{"inputs":[{"internalType":"bool","name":"activeLibrary_","type":"bool"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"ContractIsPaused","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bool","name":"active_","type":"bool"}],"name":"ContractActiveStateChange","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"ACTIVE_REINVESTS","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"REINVEST_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"bytes","name":"reinvestData","type":"bytes"},{"internalType":"bool","name":"active","type":"bool"},{"internalType":"uint8","name":"investCode","type":"uint8"},{"internalType":"address","name":"dcaAccountAddress","type":"address"}],"internalType":"struct IDCADataStructures.Reinvest","name":"reinvestData_","type":"tuple"},{"internalType":"uint256","name":"amount_","type":"uint256"}],"name":"executeReinvest","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getActiveModuals","outputs":[{"internalType":"uint8[]","name":"","type":"uint8[]"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"getLibraryVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint8","name":"code_","type":"uint8"}],"name":"getModuleName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"isActive","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"setActiveState","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"bytes","name":"reinvestData","type":"bytes"},{"internalType":"bool","name":"active","type":"bool"},{"internalType":"uint8","name":"investCode","type":"uint8"},{"internalType":"address","name":"dcaAccountAddress","type":"address"}],"internalType":"struct IDCADataStructures.Reinvest","name":"reinvestData_","type":"tuple"},{"internalType":"uint256","name":"amount_","type":"uint256"}],"name":"unwindReinvest","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]}